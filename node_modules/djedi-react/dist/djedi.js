"use strict";

exports.__esModule = true;
exports["default"] = exports.Djedi = void 0;

var _Cache = _interopRequireDefault(require("./Cache"));

var _uri = require("./uri");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var DEFAULT_CACHE_TTL = typeof window === "undefined" ? 20e3 : Infinity; // ms

var JSON_REGEX = /\bapplication\/json\b/;
var DOCUMENT_DOMAIN_REGEX = /\bdocument\.domain\s*=\s*(["'])([^'"\s]+)\1/;
var UPDATE_ADMIN_SIDEBAR_TIMEOUT = 100; // ms

/*
This class fetches and caches nodes, provides global options, and keeps
`window.DJEDI_NODES` up-to-date.
*/

var Djedi =
/*#__PURE__*/
function () {
  function Djedi() {
    this.options = makeDefaultOptions(); // `Cache<uri: string, Node>`. Cache of all fetched nodes.

    this._nodes = new _Cache["default"]({
      ttl: DEFAULT_CACHE_TTL
    }); // `Map<uri: string, { node: Node, needsRefresh: boolean }>`. Tracks
    // everything that `reportPrefetchableNode` has reported. The nodes contain
    // default values (if any). The boolean tells whether the node should be
    // re-fetched.

    this._prefetchableNodes = new Map(); // `{ [uri: string]: string }`. The return value of the last `track` call.
    // Mutated by `get` and `getBatched`. The values come from fetched nodes.

    this._lastTrack = {}; // Queue for `getBatched`.

    this._batch = makeEmptyBatch(); // `Map<uri: string, number>`. Tracks everything that `reportRenderedNode`
    // has reported. The number shows how many nodes of the `uri` in question
    // are rendered. Used to keep `_DJEDI_NODES` up-to-date.

    this._renderedNodes = new Map(); // `{ [uri: string]: string }`. The values are default values (if any). //
    // The admin sidebar expects the following mapping of all rendered nodes on
    // the page: `window.DJEDI_NODES = { "<uri>": "<default>" }`.

    this._DJEDI_NODES = {}; // Whenever a node is rendered or removed the admin sidebar needs to be
    // refreshed. This is used to batch that refreshing.

    this._updateAdminSidebarTimeoutId = undefined; // If a `<Node>` has a `runder` prop that initially returns `null`, we need
    // to observe the DOM as well to add an outline when the `<span>` finally
    // appears.

    this._mutationObserver = undefined; // Used to only warn about unknown languages once.

    this._warnedLanguages = new Set();

    if (typeof window !== "undefined") {
      if (window.DJEDI_NODES == null) {
        window.DJEDI_NODES = {};
      }

      this._DJEDI_NODES = window.DJEDI_NODES;
    }
  }

  var _proto = Djedi.prototype;

  _proto.resetOptions = function resetOptions() {
    this.options = makeDefaultOptions();
  };

  _proto.resetState = function resetState() {
    // istanbul ignore next
    if (this._batch.timeoutId != null) {
      clearTimeout(this._batch.timeoutId);
    } // istanbul ignore next


    if (this._updateAdminSidebarTimeoutId != null) {
      clearTimeout(this._updateAdminSidebarTimeoutId);
    } // istanbul ignore next


    if (this._mutationObserver != null) {
      this._mutationObserver.disconnect();
    }

    this._nodes = new _Cache["default"]({
      ttl: DEFAULT_CACHE_TTL
    });
    this._prefetchableNodes = new Map();
    this._lastTrack = {};
    this._batch = makeEmptyBatch();
    this._renderedNodes = new Map();
    this._DJEDI_NODES = {};
    this._updateAdminSidebarTimeoutId = undefined;
    this._mutationObserver = undefined;
    this._warnedLanguages = new Set();

    if (typeof window !== "undefined") {
      window.DJEDI_NODES = this._DJEDI_NODES;
    }
  };

  _proto.setCache = function setCache(ttl) {
    this._nodes.ttl = ttl;
  };

  _proto.get = function get(passedNode, callback, _temp) {
    var _this$_fetchMany,
        _this = this;

    var _ref = _temp === void 0 ? {} : _temp,
        _ref$language = _ref.language,
        language = _ref$language === void 0 ? undefined : _ref$language;

    var node = this._normalizeNode(passedNode, {
      language: language
    });

    var uri = node.uri;

    var existing = this._nodes.get(uri);

    if (existing != null) {
      this._callback(callback, existing.node);

      if (!existing.needsRefresh) {
        return;
      }
    }

    this._fetchMany((_this$_fetchMany = {}, _this$_fetchMany[node.uri] = node.value, _this$_fetchMany)).then(function () {
      if (existing == null) {
        var maybeNode = _this._nodes.get(uri);

        _this._callback(callback, maybeNode == null ? missingUriError(uri) : maybeNode.node);
      } else {// The node needed refresh and has now been refreshed and put into
        // cache. Nothing more to do.
      }
    }, function (error) {
      if (existing == null) {
        _this._callback(callback, error);
      } else {
        console.warn("djedi-react: Failed to refresh node", node, error);
      }
    });
  };

  _proto.getBatched = function getBatched(passedNode, callback, _temp2) {
    var _ref2 = _temp2 === void 0 ? {} : _temp2,
        _ref2$language = _ref2.language,
        language = _ref2$language === void 0 ? undefined : _ref2$language;

    if (this.options.batchInterval <= 0) {
      this.get(passedNode, callback, {
        language: language
      });
      return;
    }

    var node = this._normalizeNode(passedNode, {
      language: language
    });

    var existing = this._nodes.get(node.uri);

    if (existing != null) {
      this._callback(callback, existing.node);

      if (!existing.needsRefresh) {
        return;
      }
    }

    var previous = this._batch.queue.get(node.uri) || {
      node: node,
      callbacks: []
    };
    previous.callbacks.push(existing == null ? callback : function (maybeNode) {
      if (maybeNode instanceof Error) {
        console.warn("djedi-react: Failed to refresh node", node, maybeNode);
      } else {// The node needed refresh and has now been refreshed and put into
        // cache. Nothing more to do.
      }
    });

    this._batch.queue.set(node.uri, previous);

    if (this._batch.timeoutId != null) {
      return;
    }

    this._batch.timeoutId = setTimeout(this._flushBatch.bind(this), this.options.batchInterval);
  };

  _proto.reportPrefetchableNode = function reportPrefetchableNode(node) {
    var previous = this._prefetchableNodes.get(node.uri); // During development, it is not uncommon to change defaults. If so, mark
    // the node re-fetching.


    var needsRefresh = previous != null && previous.node.value !== node.value;

    this._prefetchableNodes.set(node.uri, {
      node: node,
      needsRefresh: needsRefresh
    });
  };

  _proto.prefetch = function prefetch(_temp3) {
    var _this2 = this;

    var _ref3 = _temp3 === void 0 ? {} : _temp3,
        _ref3$filter = _ref3.filter,
        filter = _ref3$filter === void 0 ? undefined : _ref3$filter,
        _ref3$extra = _ref3.extra,
        extra = _ref3$extra === void 0 ? [] : _ref3$extra,
        _ref3$language = _ref3.language,
        language = _ref3$language === void 0 ? undefined : _ref3$language;

    var nodes = {};

    this._prefetchableNodes.forEach(function (item) {
      var node = _this2._normalizeNode(item.node, {
        language: language
      });

      if (item.needsRefresh || _this2._nodes.get(node.uri) == null && (filter == null || filter(_this2._parseUri(node.uri, {
        applyDefaults: false
      })))) {
        nodes[node.uri] = node.value;
      }
    });

    extra.forEach(function (node) {
      var uri = _this2._normalizeUri(node.uri, {
        language: language
      });

      if (_this2._nodes.get(uri) == null) {
        nodes[uri] = node.value;
      }
    });
    var promise = Object.keys(nodes).length === 0 ? Promise.resolve({}) : this._fetchMany(nodes);
    return promise.then(function () {
      return undefined;
    });
  };

  _proto.track = function track() {
    this._lastTrack = {};
    return this._lastTrack;
  } // Needed to pick up the results from `prefetch` after server-side rendering.
  ;

  _proto.addNodes = function addNodes(nodes) {
    var _this3 = this;

    Object.keys(nodes).forEach(function (uri) {
      var uriObject = _this3._parseUri(uri);

      var value = nodes[uri];
      var node = {
        uri: _this3._stringifyUri(uriObject),
        value: value
      };

      _this3._nodes.set(node.uri, node); // If the returned node URI has a version, also set the versionless URI to
      // the same node. A request for `home/text.md` can return a URI ending
      // with for example `home/text.md#1` if the user has edited the node.


      if (uriObject.version) {
        var versionlessUri = _this3._stringifyUri(_extends({}, uriObject, {
          version: ""
        }));

        _this3._nodes.set(versionlessUri, node);
      }
    });
  };

  _proto.injectAdmin = function injectAdmin() {
    var _this4 = this;

    if (typeof document === "undefined") {
      return Promise.resolve(false);
    }

    var url = this.options.baseUrl + "/embed/";
    return this._fetch(url, {
      credentials: "include"
    }).then(function (response) {
      // If the user is not logged in as an admin, the API responds with 204 No
      // Content. Also handle 403 Forbidden for backwards compatibility.
      if (response.status === 204 || response.status === 403) {
        return false;
      }

      if (response.status >= 200 && response.status < 400) {
        return response.text().then(function (html) {
          // Browsers don’t allow <script> tags inserted as part of an HTML
          // chunk to modify `document.domain`, so cut out the domain and set it
          // manually.
          var _ref4 = DOCUMENT_DOMAIN_REGEX.exec(html) || [],
              domain = _ref4[2];

          if (domain != null) {
            document.domain = domain;
          } // When hot-reloading code, remove any old iframe first.


          updateAdminSidebar({
            remove: true
          });
          document.body.insertAdjacentHTML("beforeend", html);

          _this4._installMutationObserver();

          return true;
        });
      }

      return Promise.reject(createStatusCodeError(response));
    });
  };

  _proto.removeAdmin = function removeAdmin() {
    if (typeof document === "undefined") {
      return;
    } // istanbul ignore next


    if (this._updateAdminSidebarTimeoutId != null) {
      clearTimeout(this._updateAdminSidebarTimeoutId);
    } // istanbul ignore next


    if (this._mutationObserver != null) {
      this._mutationObserver.disconnect();
    }

    updateAdminSidebar({
      remove: true
    });
  };

  _proto.reportRenderedNode = function reportRenderedNode(passedNode, _temp4) {
    var _ref5 = _temp4 === void 0 ? {} : _temp4,
        _ref5$language = _ref5.language,
        language = _ref5$language === void 0 ? undefined : _ref5$language;

    var node = this._normalizeNode(passedNode, {
      language: language
    });

    var previous = this._renderedNodes.get(node.uri);

    var numInstances = previous == null ? 1 : previous + 1;

    this._renderedNodes.set(node.uri, numInstances);

    this._DJEDI_NODES[this._djediNodesUri(node.uri)] = node.value; // Always update the sidebar, to keep outlines up-to-date.

    this._updateAdminSidebar();
  };

  _proto.reportRemovedNode = function reportRemovedNode(passedUri, _temp5) {
    var _ref6 = _temp5 === void 0 ? {} : _temp5,
        _ref6$language = _ref6.language,
        language = _ref6$language === void 0 ? undefined : _ref6$language;

    var uri = this._normalizeUri(passedUri, {
      language: language
    });

    var previous = this._renderedNodes.get(uri);

    if (previous == null) {
      return;
    }

    var numInstances = previous - 1;

    if (numInstances <= 0) {
      this._renderedNodes["delete"](uri);

      delete this._DJEDI_NODES[this._djediNodesUri(uri)];
    } else {
      this._renderedNodes.set(uri, numInstances);
    } // Always update the sidebar, to keep outlines up-to-date.


    this._updateAdminSidebar();
  };

  _proto.element = function element(uri) {
    var uriObject = this._parseUri(uri);

    return {
      tag: "span",
      attributes: {
        "data-i18n": this._stringifyUri(_extends({}, uriObject, {
          scheme: "",
          ext: "",
          version: ""
        }))
      }
    };
  } // Calls `callback(node)` and also updates the last return value of
  // `djedi.track()`. This is really ugly but needed for server-side rendering.
  ;

  _proto._callback = function _callback(callback, node) {
    if (!(node instanceof Error)) {
      this._lastTrack[node.uri] = node.value;
    }

    callback(node);
  };

  _proto._parseUri = function _parseUri(uri, _temp6) {
    var _ref7 = _temp6 === void 0 ? {} : _temp6,
        _ref7$applyDefaults = _ref7.applyDefaults,
        applyDefaults = _ref7$applyDefaults === void 0 ? true : _ref7$applyDefaults,
        _ref7$language = _ref7.language,
        passedLanguage = _ref7$language === void 0 ? this.options.languages["default"] : _ref7$language;

    var _this$options$uri = this.options.uri,
        defaults = _this$options$uri.defaults,
        namespaceByScheme = _this$options$uri.namespaceByScheme,
        separators = _this$options$uri.separators;
    var uriObject = (0, _uri.parseUri)(uri, separators);

    if (!applyDefaults) {
      return uriObject;
    }

    var language = passedLanguage;
    var allLanguages = [this.options.languages["default"]].concat(this.options.languages.additional);

    if (allLanguages.indexOf(language) === -1) {
      var fallback = this.options.languages["default"];

      if (!this._warnedLanguages.has(language)) {
        this._warnedLanguages.add(language);

        console.warn("djedi-react: Ignoring unknown language", {
          actual: language,
          expected: allLanguages,
          fallback: fallback
        });
      }

      language = fallback;
    }

    return (0, _uri.applyUriDefaults)(uriObject, defaults, namespaceByScheme, {
      language: language
    });
  };

  _proto._stringifyUri = function _stringifyUri(uriObject) {
    return (0, _uri.stringifyUri)(uriObject, this.options.uri.separators);
  };

  _proto._normalizeUri = function _normalizeUri(uri, _ref8) {
    var _ref8$language = _ref8.language,
        language = _ref8$language === void 0 ? undefined : _ref8$language;
    return this._stringifyUri(this._parseUri(uri, {
      language: language
    }));
  };

  _proto._normalizeNode = function _normalizeNode(node, _ref9) {
    var _ref9$language = _ref9.language,
        language = _ref9$language === void 0 ? undefined : _ref9$language;
    return _extends({}, node, {
      uri: this._normalizeUri(node.uri, {
        language: language
      })
    });
  };

  _proto._djediNodesUri = function _djediNodesUri(uri) {
    var uriObject = this._parseUri(uri);

    return this._stringifyUri(_extends({}, uriObject, {
      version: ""
    }));
  };

  _proto._flushBatch = function _flushBatch() {
    var _this5 = this;

    var queue = this._batch.queue;
    var nodes = {};
    queue.forEach(function (data, uri) {
      nodes[uri] = data.node.value;
    });
    this._batch = makeEmptyBatch();

    this._fetchMany(nodes).then(function () {
      queue.forEach(function (data, uri) {
        var maybeNode = _this5._nodes.get(uri);

        var node = maybeNode == null ? missingUriError(uri) : maybeNode.node;
        data.callbacks.forEach(function (callback) {
          _this5._callback(callback, node);
        });
      });
    }, function (error) {
      queue.forEach(function (data) {
        data.callbacks.forEach(function (callback) {
          _this5._callback(callback, error);
        });
      });
    });
  };

  _proto._fetchMany = function _fetchMany(nodes) {
    var _this6 = this;

    // `JSON.stringify` excludes keys whose values are `undefined`. Change them
    // to `null` so that all keys are sent to the backend.
    var nodesWithNull = Object.keys(nodes).reduce(function (result, key) {
      var value = nodes[key];
      result[key] = value === undefined ? null : value;
      return result;
    }, {});
    return this._post("/nodes/", nodesWithNull).then(function (results) {
      if (typeof results === "object" && results != null) {
        _this6.addNodes(results);

        return results;
      }

      return Promise.reject(new TypeError("djedi-react: Expected the API to return an object of nodes, but got: " + JSON.stringify(results)));
    });
  };

  _proto._fetch = function _fetch(url, options) {
    var fetch = this.options.fetch; // `this.options.fetch(url, options)` does not work, since it calls the
    // function with `this.options` as context/`this` instead of `window`, which
    // the standard `fetch` function does not support (it throws an error).

    return fetch(url, options);
  };

  _proto._post = function _post(passedUrl, data) {
    var url = "" + this.options.baseUrl + passedUrl;
    return this._fetch(url, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: // Make the body easier to read in test snapshots. It’s important to
      // still call `JSON.stringify` so we know that `data` actually can be
      // stringified.
      // istanbul ignore next
      // eslint-disable-next-line no-undef
      typeof process !== "undefined" && process.env.NODE_ENV === "test" ? JSON.parse(JSON.stringify(data)) : JSON.stringify(data)
    }).then(function (response) {
      response.__input = data;
      var isJSON = JSON_REGEX.test(response.headers.get("Content-Type"));
      return (isJSON ? response.json() : response.text()).then(function (body) {
        response.__output = body;
        return response.status >= 200 && response.status < 400 ? body : Promise.reject(createStatusCodeError(response));
      });
    }, function (passedError) {
      // In IE11 the error can be a `ProgressEvent` (I guess it’s due to how
      // the `unfetch` “polyfill” is implemented). Make sure to always
      // return `Error`s so `foo instanceof Error` checks can be used.
      // istanbul ignore next
      var error = passedError instanceof Error ? passedError : new Error("fetch error");
      return Promise.reject(error);
    })["catch"](function (error) {
      var response = error.response;
      error.message = "djedi-react: " + (response == null ? "(no response)" : response.status + " " + response.statusText) + " POST " + url + ":\n" + error.message;
      return Promise.reject(error);
    });
  };

  _proto._updateAdminSidebar = function _updateAdminSidebar() {
    var _this7 = this;

    if (this._updateAdminSidebarTimeoutId != null) {
      clearTimeout(this._updateAdminSidebarTimeoutId);
    }

    this._updateAdminSidebarTimeoutId = setTimeout(function () {
      _this7._updateAdminSidebarTimeoutId = undefined;
      updateAdminSidebar();
    }, UPDATE_ADMIN_SIDEBAR_TIMEOUT);
  } // There was no good way of testing `MutationObserver` when this was written,
  // so test the `_onMutation` method is tested instead.
  // istanbul ignore next
  ;

  _proto._installMutationObserver = function _installMutationObserver() {
    if (typeof MutationObserver === "undefined") {
      return;
    } // When hot-reloading code, disconnect the old observer and install a new one.


    if (this._mutationObserver != null) {
      this._mutationObserver.disconnect();
    }

    this._mutationObserver = new MutationObserver(this._onMutation.bind(this));

    this._mutationObserver.observe(document.documentElement, {
      childList: true,
      subtree: true
    });
  };

  _proto._onMutation = function _onMutation(records) {
    var _this8 = this;

    var element = this.element("");

    function isNodeWrapper(domNode) {
      return domNode.nodeName === element.tag.toUpperCase() && Object.keys(element.attributes).every(function (attribute) {
        return domNode.hasAttribute(attribute);
      });
    }

    function needsUpdate(domNodes) {
      return [].some.call(domNodes, function (domNode) {
        return isNodeWrapper(domNode) || domNode.querySelectorAll != null && [].some.call(domNode.querySelectorAll("*"), isNodeWrapper);
      });
    }

    records.forEach(function (record) {
      if (needsUpdate(record.addedNodes) || needsUpdate(record.removedNodes)) {
        _this8._updateAdminSidebar();
      }
    });
  };

  return Djedi;
}(); // This is a function, not a constant, since it can be mutated by the user.


exports.Djedi = Djedi;

function makeDefaultOptions() {
  return {
    baseUrl: "/djedi",
    batchInterval: 10,
    // ms
    defaultRender: function defaultRender(state) {
      switch (state.type) {
        case "loading":
          return "Loading…";

        case "error":
          return "Failed to fetch content \uD83D\uDE1E (" + (state.error.response != null ? state.error.response.status : -1) + ")";

        case "success":
          return state.content;
        // istanbul ignore next

        default:
          return null;
      }
    },
    fetch: defaultFetch,
    languages: {
      "default": "en-us",
      additional: []
    },
    uri: {
      defaults: {
        scheme: "i18n",
        namespace: "",
        path: "",
        ext: "txt",
        version: ""
      },
      namespaceByScheme: {
        i18n: "{language}",
        l10n: "local",
        g11n: "global"
      },
      separators: {
        scheme: "://",
        namespace: "@",
        path: "/",
        ext: ".",
        version: "#"
      }
    }
  };
}

function defaultFetch() {
  throw new Error("djedi-react: You must set `djedi.options.fetch`.");
} // This is a function, not a constant, since it will be mutated.


function makeEmptyBatch() {
  return {
    timeoutId: undefined,
    queue: new Map()
  };
}

function createStatusCodeError(response) {
  var error = new Error("Non-success status code: " + response.status);
  error.response = response;
  return error;
}

function missingUriError(uri) {
  return new Error("Missing result for node: " + uri);
}

function updateAdminSidebar(_temp7) {
  var _ref10 = _temp7 === void 0 ? {} : _temp7,
      _ref10$remove = _ref10.remove,
      remove = _ref10$remove === void 0 ? false : _ref10$remove;

  if (typeof document === "undefined") {
    return;
  }

  var iframe = document.getElementById("djedi-cms");

  if (iframe == null) {
    return;
  } // The sidebar sets a width on `<html>` when the sidebar is open.


  document.documentElement.style.width = ""; // Remove old outline elements.

  [].forEach.call(document.querySelectorAll(".djedi-node-outline"), function (element) {
    element.parentNode.removeChild(element);
  });

  if (remove) {
    // Remove the iframe.
    iframe.parentNode.removeChild(iframe);
  } else {
    // Reload the iframe.
    // eslint-disable-next-line no-self-assign
    iframe.src = iframe.src;
  }
}

var _default = new Djedi();

exports["default"] = _default;