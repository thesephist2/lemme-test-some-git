"use strict";

exports.__esModule = true;
exports["default"] = exports.NodeContext = void 0;

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireDefault(require("react"));

var _djedi = _interopRequireDefault(require("./djedi"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var POTENTIAL_HTML = /[<&]/;

var NodeContext = _react["default"].createContext();

exports.NodeContext = NodeContext;
var propTypes = {
  uri: _propTypes["default"].string.isRequired,
  children: _propTypes["default"].string,
  // Yes, a *string*!
  edit: _propTypes["default"].bool,
  render: _propTypes["default"].func // ...variables: {[string]: any}.

};
var defaultProps = {
  edit: true,
  children: undefined,
  render: undefined
};

var Node =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose(Node, _React$Component);

  function Node(props) {
    var _this;

    _this = _React$Component.call(this, props) || this;
    _this.state = {
      node: undefined
    };
    _this.language = _djedi["default"].options.languages["default"];
    _this.lastLanguage = _this.language;
    _this.firstRender = true;
    _this.mounted = false;
    return _this;
  }

  var _proto = Node.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this._updateLanguage();

    this.lastLanguage = this.language;
    this.mounted = true;

    _djedi["default"].reportRenderedNode({
      uri: this.props.uri,
      value: this._getDefault()
    }, {
      language: this.language
    });
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    this._updateLanguage();

    if (this.props.uri !== prevProps.uri || this.language !== this.lastLanguage) {
      this._get();

      _djedi["default"].reportRemovedNode(prevProps.uri, {
        language: this.lastLanguage
      });

      _djedi["default"].reportRenderedNode({
        uri: this.props.uri,
        value: this._getDefault()
      }, {
        language: this.language
      });
    }

    if (this.props.uri === prevProps.uri && this.props.children !== prevProps.children) {
      console.error("djedi-react: Changing the default value of a node is not supported.", {
        prev: prevProps.children,
        next: this.props.children
      });
    }

    this.lastLanguage = this.language;
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.mounted = false;

    _djedi["default"].reportRemovedNode(this.props.uri, {
      language: this.language
    });
  };

  _proto._get = function _get() {
    var _this2 = this;

    _djedi["default"].getBatched({
      uri: this.props.uri,
      value: this._getDefault()
    }, function (node) {
      if (_this2.mounted) {
        _this2.setState({
          node: node
        });
      } else {
        // If the node already exists in cache, this callback is called
        // immediately (synchronously). If this happens in the `_get()` call in
        // `constructor`, where it is not allowed to call `setState`, mutate
        // `this.state` directly instead (which is fine in the `constructor`).
        // eslint-disable-next-line react/no-direct-mutation-state
        _this2.state.node = node;
      }
    }, {
      language: this.language
    });
  };

  _proto._getDefault = function _getDefault() {
    var children = this.props.children;
    return children == null ? undefined : String(children);
  };

  _proto._updateLanguage = function _updateLanguage() {
    this.language = this.context == null ? _djedi["default"].options.languages["default"] : this.context;
  };

  _proto.render = function render() {
    // The following cannot be done in `componentDidMount` because of
    // server-side rendering. This used to be done in `constructor`, but that
    // doesn't work since `this.context` isn't available yet.
    //
    // In React’s StrictMode/ConcurrentMode, components may be instantiated
    // multiple times, which means that `this._get()` might be called several
    // times for a single `<Node>`. It doesn’t matter though, because it does
    // not cause any extra fetching. And the callback (in `this._get`) will just
    // do `this.state.node = node` (`this.mounted` stays `false`) on a dead
    // instance which should be harmless (and not cause any extra rendering or
    // so).
    if (this.firstRender) {
      this._updateLanguage();

      this.lastLanguage = this.language;
      this.firstRender = false;

      this._get();
    }

    var _this$props = this.props,
        uri = _this$props.uri,
        children = _this$props.children,
        edit = _this$props.edit,
        _this$props$render = _this$props.render,
        render = _this$props$render === void 0 ? _djedi["default"].options.defaultRender : _this$props$render,
        variables = _objectWithoutPropertiesLoose(_this$props, ["uri", "children", "edit", "render"]);

    var node = this.state.node;
    var language = this.language;

    if (node == null) {
      return render({
        type: "loading"
      }, {
        language: language
      });
    }

    if (node instanceof Error) {
      return render({
        type: "error",
        error: node
      }, {
        language: language
      });
    } // If there’s neither a default value nor a database value, `node.value`
    // will be `null`.


    var value = interpolate(node.value || "", variables);

    var element = _djedi["default"].element(node.uri); // This is mostly to make the test snapshots easier to read. Might be faster
    // not using `dangerouslySetInnerHTML` unnecessarily, too.


    var hasHtml = POTENTIAL_HTML.test(value);
    var content = edit ? hasHtml ? _react["default"].createElement(element.tag, _extends({}, element.attributes, {
      dangerouslySetInnerHTML: {
        __html: value
      }
    })) : _react["default"].createElement(element.tag, element.attributes, value) : // NOTE: It’s not possible to render HTML without a wrapper element in
    // React. So you can’t do `edit={false}` and expect the node value to be
    // treated as HTML.
    value;
    return render({
      type: "success",
      content: content
    }, {
      language: language
    });
  };

  return Node;
}(_react["default"].Component);

exports["default"] = Node;
Node.propTypes = propTypes;
Node.defaultProps = defaultProps;
Node.contextType = NodeContext;
var INNER = /[^{}[\]\s]+/.source;
var INTERPOLATION_REGEX = RegExp("\\{" + INNER + "\\}|\\[" + INNER + "\\]", "g");
/*
This intentionally only supports `{key}`, not any of the fancy Python string
formatting extras. If `key` maps to a string in `variables`, that string is
inserted. Otherwise it is kept as-is. No escaping, no nothing. KISS and
YAGNI. If somebody does want fancy extras, they can do it themselves before
putting the value in `variables`.

Also support `[key]`, since `{foo}` is already used in JSX syntax:

    const user = "Bob"
    <Node uri="test">Hello, {user}!</Node>
    <Node uri="test">Hello, [user]!</Node>
    <Node uri="test">{`Hello, {user}!`}</Node>
*/

function interpolate(string, variables) {
  return string.replace(INTERPOLATION_REGEX, function (match) {
    var key = match.slice(1, -1);
    return Object.prototype.hasOwnProperty.call(variables, key) ? variables[key] : match;
  });
}